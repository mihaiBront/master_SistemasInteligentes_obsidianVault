{"path":"_aula_virtual/SJK002/LABS/lab2.pdf","text":"Computer Vision M ´aster en Sistemas Inteligentes (Universitat Jaume I) 2. Spatial ﬁltering Abstract We will learn how to inject different types and amounts of image noise, and to remove it or reduce it through spatial-domain ﬁltering. In practice, introducing noise on purpose can serve two purposes: to learn about these noises, and to study the effect of different types of ﬁltering in controlled conditions. We will look at different ﬁlters and their pros and cons. It is essential that you understand which ﬁlter is more adequate for each type of noise. Keywords Salt-and-pepper noise • Gaussian noise • Median, mean, and Gaussian ﬁlters Contents 1 Generating noisy images 1 2 Image ﬁltering 1 3 Exercises 1 1. Generating noisy images Salt-and-pepper noise We will produce salt-and-pepper noise with basic NumPy operations. As in other cases where code is provided, it is very important that you understand what each part of the code does and for which purpose, so that you can learn to write or modify code for similar situations. Gaussian noise To produce Gaussian noise, we use the module numpy.rando m. Notice that we do not use a function that directly applies the noise to an image, but we ﬁrst generate Gaussian noise in an array of the same size of the original image, and then add this result to the image.◃ E4 Try also with Gaussian noise with σ twice the maximum value used in the original code. 2. Image ﬁltering To assess the practical value of a ﬁlter like those studied here, we need to consider, at least: (1) its effectiveness in denoising; (2) its behaviour preserving object edges; and (3) its computational cost as a function of the mask (ﬁlter) size.◃ E1 Mean ﬁlter To apply the mean ﬁlter, we will procede in a general way: the mask of the given size is ﬁrst created, and then a convolution is applied.◃ E2 Make sure you understand how the mask is deﬁned in the provided code. For convolution, the module sci py.ndimage.filters is used. Note that the given code applies the mean ﬁlter to images with salt-and-peper noise. Discuss how effective is this ﬁlter for that type of noise. Gaussian ﬁlter For the Gaussian ﬁlter, we use the module scipy.ndimage .filters.◃ E3 As you can see, this ﬁlter is applied to images with Gaussian noise. Does this ﬁlter work for this noise? Experiment with several values of the standard deviation of the noise and several values of the standard deviation of the Gaussian ﬁlter. Please, pay attention to the fact that Gaussian functions are used both for the noise and for the ﬁlter, but with different meanings; do not get confused, and make sure you understand what the Gaussian function represent in each case. To better appreciate the ﬁltering result, you can zoom in on a relatively small area of the image (e.g. the nose, an eye, or a part of the hat). ◃ E7 Median ﬁlter Now we use the module scipy.signal. Observe the effect of the median ﬁlter on salt-and-pepper noise. With respect to the mean ﬁlter, is the median ﬁlter more or less effective? Why? Does the same happen if the ﬁlter size is “very high”? 3. Exercises 1. Prepare a double-entry table with types of noise and types of ﬁlters. In each table cell, write how effective that ﬁlter is for that noise. Add some comments or notes about the noise level that can be considered, or which ﬁlter parameters can be adequate, and possible “side effects” over the image (e.g. maybe a given ﬁlter decreases the amount of noise but also has a negative impact on other aspects of the image). Finally, you may include additional comments highlighting the key features of each ﬁlter, or comparing among them. 2. As you know, the mean ﬁlter is separable. What does this imply? Well, we can obtain the same result by applying sequentially two 1D ﬁlters (one over rows and the other over columns) that by applying one 2D ﬁlter, with the beneﬁt that the cost of applying two one- dimensional ﬁlters is smaller than that of applying a single 2D ﬁlter. Write the separable version average 2. Spatial ﬁltering — 2/2 (a) gv1d (b) gv1d as an image (c) gv2d as an image Figure 1. The discretized Gaussian: 1D (a,b) and 2D (c), for n = 15 y σ = 4. FilterSep(), of the mean ﬁlter given in average Filter(). Check that the results are equivalent and compare the running times with increasing image and mask sizes. Plot these times using Matplotlib for a visual analysis. 3. In our code, we used directly the function gaussian filte r() to apply the gaussian ﬁlter. Now, we are going to do it with an explicit convolution, as we did with the mean ﬁlter, i.e. mask creation + convolution. Let’s proceed step by step: (a) Use the function gaussian() of scipy.signal to generate an array of size n × 1 with the values of a 1D Gaussian of the given size n and standard devi- ation σ . Let gv1d be this vector. Display gv1d with Matplotlib, as if it was an image, without any interpolation (interpolation=’none’). (b) Generate an n × n matrix with the values of 2D Gaussian (as before, for the given n and σ ). Let gv2d be this matrix. You can get gv2d by a matrix product of gv1d and its transpose, either with gv1d * gv1d.T, or np.outer(gv1d, gv1d). Display gv2d as an image. Fig. 1 shows an example of both gv1d and gv2d using a color map. (c) Finally, use gv2d as a mask (kernel) to convolve the image to be ﬁltered. Compare the result ob- tained now with that we obtained using gaussi an filter(). (d) The Gaussian ﬁlter is also separable, as you know. Therefore, for the sake of efﬁciency, instead of applying the convolution with the 2D mask, let’s apply it with two convolutions of the 1D masks (gv1d and its transpose). Compare the result with that of the 2D convolution in the previous step. 4. Generalize the function addGaussianNoise() for it to work both for gray-level and color images. As usual, apply the ﬁlter to each of the color bands, sep- arately. Then, ﬁnd out whether this band-wise appli- cation of the ﬁlter is actually required, and why (not). 5. The quotient image is obtained by pixel-wise division of an image I and its blurred version I ∗Gσ , where Gσ is a 2D Gaussian kernel with standard deviation σ . Write a function quotientImage(im,sigma) that re- turns the quotient image for I=im with σ =sigma. Test it on some images and think of its possible useful- ness. 6. (Optional) Earlier, when we displayed the original and modiﬁed images in the same Matplotlib ﬁgure, we dis- played the parameters of the operation as part of the ﬁgure title. However, in this and other cases, it is con- venient to have, in addition to this general title, in- dividual titles for each part of the ﬁgure. Thus, this would serve to show the values of the parameters next to each corresponding image, for higher clarity. Include this possibility by means of an additional parameter to showInGrid() which consists of a list of strings (one string per element to be displayed). On the other hand, ﬁnd out how we can display text that includes Greek letters and math symbols, such as “σ = 2” in- stead of “sigma=2”. 7. (Optional) Above, we suggested you to zoom in on an area within an image to better perceive the noise or the effect of some ﬁlter. Doing this interactively is bearable if we have to repeat it only a few times, but be- comes tiresome when performed multiple times. How can we be more efﬁcient? We can directly (by code) display an area of interest of the image, instead of the whole image. To do so, add an additional parameter to showInGrid() which represents the rectangular region we want to display. Test it with, say, Lena’s nose. Another issue is: how can we found out quickly and approximately the coordinates of some region of inter- est? We can hover the mouse over an image displayed with Matplotlib and look at the bottom of the window, where the coordinates are displayed.","libVersion":"0.3.2","langs":""}