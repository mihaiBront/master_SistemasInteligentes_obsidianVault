{"path":"_aula_virtual/SJK003/16-reinforcementLearning.pdf","text":"RamÃ³n A. Mollineda CÃ¡rdenas reinforcement learning MACHINE LEARNING University Master's Degree in Intelligent Systems a quote â€œWhen it is not in our power to determine what is true, we ought to follow what is most probable.â€ â€• RenÃ© Descartes french philosopher, mathematician and scientist 1596 â€“ 1650 introduction to reinforcement learning use case Source: Reinforcement learning. Mathworks.com (link). introduction pipeline Source: EBatlleP, CC BY-SA 4.0 <https://creativecommons.org/licenses/by-sa/4.0>, via Wikimedia Commons. sample actions, observe rewards, tune the policy introduction agent Source: SUTTON, Richard S.; BARTO, Andrew G. Reinforcement learning: An introduction. MIT press, 2018. â€¢ an agent is an entity that interacts with an environment â€¢ it receives information from sensing the environments â€¢ it interacts with the environment using its actuators â€¢ its interactions are based on a policy (agent's brain) introduction use case Source: SUTTON, Richard S.; BARTO, Andrew G. Reinforcement learning: An introduction. MIT press, 2018. goal? agent? state? action? environment? short-term rewards? long-term rewards? A mobile robot decides whether it should enter a new room to collect more trash or try to find its way back to its battery recharging station. It makes its decision based on the current charge level of its battery and how quickly it was able to find the recharger in the past. introduction goal RL approach involves learning how to map states to actions, so as to gain the highest long-term cumulative reward. introduction RL summary Source: Satwik Kansal, Brendan Martin. Reinforcement Q-Learning from Scratch in Python with OpenAI Gym. LearnDataSci, 2023. 1. The agent observes the environment state (environment observation) 2. The agent decides how to act base on some strategy (policy) that maps states into actions; at the beginning, through trial and error 3. The agent acts according to the policy 4. The agent receives a reward or penalty (based on sensor reading) 5. Learning from the experiences and refining the strategy (policy) 6. Iterate until an optimal strategy is found introduction learning paradigms Source: Reinforcement learning. Mathworks.com (link). unsupervised learning supervised learning reinforcement learning introduction learning paradigms â€¢ unsupervised learningâ€¦ o discovers similarities between data samples o identifies clusters based on similarities o is able to detect anomalous data â€¢ supervised learningâ€¦ o learns a mapping from instances to data labels o requires a labelled / annotated dataset o uses labels to guide, correct and monitor the learning process â€¢ reinforcement learningâ€¦ o given a state, there exists an optimal action, but it is not known! o takes actions based on short- and long-term reward (strategy learning) o is guided by sparse and uncertain feedback / supervision o does not require collecting, preprocessing and labeling data before training Source: Chris V. Nicholson. A Beginner's Guide to Deep Reinforcement Learning. Pathmind Inc., 2023. introduction learning paradigms Source: Deepika Yadav. DIFFERENT MACHINE LEARNING MODELS, medium.com, 2022. (link). introduction key principles â€¢ it is a closed-loop problem: system's actions affect later inputs. â€¢ actions may affect not only the immediate reward but also the next states and, through that, all subsequent rewards. â€¢ the agent is not taught what action to take on each state (as in supervised learning); instead, it must discover which action maximizes immediate and future rewards (by interacting with the environment). Source: SUTTON, Richard S.; BARTO, Andrew G. Reinforcement learning: An introduction. MIT press, 2018. introduction exploitation â€“ exploration dilemma / trade-off exploit known actions that have proven to be effective (positive rewards) OR explore new (unknown) actions to discover more promising solutions Source: SUTTON, Richard S.; BARTO, Andrew G. Reinforcement learning: An introduction. MIT press, 2018. introduction key elements â€¢ a policy ğœ‹: the brain of a RL agent o a mapping from perceived states to actions to be taken o a stimulus-response rule â€¢ a reward signal: what is good in an immediate sense o ğ‘Ÿ âˆ¶ ğ‘† Ã— ğ´ â†’ â„ o the agent cannot alter ğ‘Ÿ o measures the effectiveness/quality of the agentâ€™s interaction â€¢ a value function: what is good in the long run (accumulated rewards) o maps a state to the expected return (cumulative reward) when starting from that state o measures the quality of (some sequence of) actions taken from a state o policy tuning is based on value judgments â€¢ a model of the environment: it mimics the behavior of the environment o given a state and action, it moves to the next state and provides a reward Source: SUTTON, Richard S.; BARTO, Andrew G. Reinforcement learning: An introduction. MIT press, 2018. objective function over an episode à· ğ‘¡=0 âˆ ğ›¾ğ‘¡ğ‘Ÿ ğ‘  ğ‘¡ , ğ‘ ğ‘¡ ğ‘¡: time step ğ‘Ÿ: reward function ğ›¾: discount factor ğ‘ (ğ‘¡): state at a given time step/epoch ğ‘¡ ğ‘ ğ‘¡ = ğœ‹ ğ‘  ğ‘¡ policy agentâ€˜s goal à· ğ‘¡=0 âˆ ğ›¾ğ‘¡ğ‘Ÿ ğ‘  ğ‘¡ , ğœ‹ ğ‘  ğ‘¡ policy agentâ€˜s goal â‚¿1.13 policy agentâ€˜s goal ğœ‹âˆ— = ğ‘ğ‘Ÿğ‘”ğ‘šğ‘ğ‘¥ğœ‹ à· ğ‘¡=0 âˆ ğ›¾ğ‘¡ ğ‘Ÿ ğ‘  ğ‘¡ , ğœ‹ ğ‘  ğ‘¡ ğœ‹ : ğ’® â†’ ğ’œ ğ’® ~ state space ğ’œ ~ action space RL paradigms tabular solutions: the action-value function is represented as an array or a table approximate, gradient-descent, solutions: the state-action spaces involve continuous domains or complex representations (e.g., an image) Source: SUTTON, Richard S.; BARTO, Andrew G. Reinforcement learning: An introduction. MIT press, 2018. tabular solutions representative methods tabular solutions â€¢ Q-learning: off policy, model-free RL â€¢ State-Action-Reward-State-Action (SARSA): on policy, model-free RL Source: SUTTON, Richard S.; BARTO, Andrew G. Reinforcement learning: An introduction. MIT press, 2018. Q-learning* off policy, model-free RL algorithm â€¢ ğ‘„-learning approximates the optimal action-value function ğ‘„âˆ— that maximizes the expected value over all successive steps** ğ‘„: ğ‘† Ã— ğ´ â†’ â„ â€¢ ğ‘„-learning does not require an environment model (model-free) â€¢ ğœ‹ (policy) depends on ğ‘„ â€¢ ğ‘„ depends on ğœ‹ (ğœ‹ determines which state-action pair should be updated) â€¢ ğ‘„â€™s update (learning) does not depend on ğœ‹ (off policy) * Watkins, C.J.C.H., Dayan, P. Q-learning. Mach Learn 8, 279â€“292 (1992). https://doi.org/10.1007/BF00992698. ** ğ‘„ has been shown to converge with probability 1 to ğ‘„âˆ— under minimal requirements. Q-learning Bellman equation where... â€¢ ğ‘ğ‘¡ = ğœ‹ ğ‘ ğ‘¡ â€¢ ğ‘Ÿğ‘¡+1 is the reward associated to the state-action pair ğ‘ ğ‘¡, ğ‘ğ‘¡ â€¢ ğ‘ ğ‘¡+1 is the new state after selecting the action ğ‘ğ‘¡ at state ğ‘ ğ‘¡ â€¢ ğ›¼ is the learning rate 0 â‰¤ ğ›¼ â‰¤ 1 ; the extent to which our ğ‘„-values are being updated in every iteration â€¢ ğ›¾ is the discount factor 0 â‰¤ ğ›¾ â‰¤ 1 ; relevance of future rewards (uncertain) â€¢ ğ‘šğ‘ğ‘¥ğ‘ğ‘„ ğ‘ ğ‘¡+1, ğ‘ is the maximum value from state ğ‘ ğ‘¡+1 (given the current ğ‘„) Source: Q-learning. Wikipedia.org. ğ‘„ ğ‘ ğ‘¡, ğ‘ğ‘¡ = 1 âˆ’ ğ›¼ Â· ğ‘„ ğ‘ ğ‘¡, ğ‘ğ‘¡ + ğ›¼ Â· ğ‘Ÿğ‘¡+1 + ğ›¾ Â· ğ‘šğ‘ğ‘¥ğ‘ğ‘„ ğ‘ ğ‘¡+1, ğ‘ Q-learning off-policy learning â€¢ the behavior policy (used to collect data) is different from the policy being optimized â€¢ ğ‘„'s update (learning) does not involve the behavior policy ğœ‹ â€¢ ğ‘„'s update depends on ğ‘šğ‘ğ‘¥ğ‘ğ‘„ ğ‘ ğ‘¡+1, ğ‘ , a greedy action from ğ‘ ğ‘¡+1 â€¢ it is usually assumed an ğ˜€-greedy behavior policy ğœ‹ ğ‘„ ğ‘ ğ‘¡, ğ‘ğ‘¡ = 1 âˆ’ ğ›¼ Â· ğ‘„ ğ‘ ğ‘¡, ğ‘ğ‘¡ + ğ›¼ Â· ğ‘Ÿğ‘¡+1 + ğ›¾ Â· ğ‘šğ‘ğ‘¥ğ‘ğ‘„ ğ‘ ğ‘¡+1, ğ‘ ğ‘ âˆˆ 0,1 random exploration exploitation ğ‘ < ğ˜€ ğ‘ â‰¥ ğ˜€ random action best known action ğ‘ğ‘Ÿğ‘”ğ‘šğ‘ğ‘¥ğ‘ğ‘„ ğ‘ , ğ‘ Q-learning Bellman equation: remarks â€¢ the Bellman equation is a recursion that computes the weighted average of the current value and a new learned value â€¢ an episode of the algorithm ends when state ğ‘ ğ‘¡+1 is a final state â€¢ action values are finite even when no final state exists (provided that ğ›¾ < 1) â€¢ for final states ğ‘ ğ‘“, ğ‘„ ğ‘ ğ‘“, ğ‘ is set to the reward observed and is never updated â€¢ ğ›¼ determines to what extent newly acquired information overrides old information o ğ›¼ = 0 makes the the agent learn nothing (exclusively exploiting prior knowledge) o ğ›¼ = 1 makes the agent ignore prior knowledge (to explore new possibilities) â€¢ ğ›¾ determines the importance of future rewards o ğ›¾ = 0 makes the agent â€œmyopicâ€ o ğ›¾ â‰¥ 1 the action values might diverge â€¢ ğ‘„-learning fails with an infinite (or even large) number of states/actions Source: Q-learning. Wikipedia.org. Q-learning algorithm Source: SUTTON, Richard S.; BARTO, Andrew G. Reinforcement learning: An introduction. MIT press, 2018. SARSA: State-Action-Reward-State-Action* on policy, model-free RL algorithm * RUMMERY, G.A.; NIRANJAN, M. On-line Q-learning using connectionist systems. Univ. of Cambridge, Dept. of Engineering, UK, 1994. â€¢ SARSA estimates ğ‘„ğœ‹ ğ‘ , ğ‘ for the current agent policy ğœ‹ and for all state-action pairs ğ‘ , ğ‘ . ğ‘„ğœ‹: ğ‘† Ã— ğ´ â†’ â„ â€¢ SARSA does not require an environment model (model-free) â€¢ ğœ‹ depends on ğ‘„; ğ‘„ depends on ğœ‹ (ğœ‹ determines which state-action pair should be updated), and ğ‘„â€™s update does depend on ğœ‹ (on policy) â€¢ SARSA explicitly uses the transition from one state-action pair to the next state-action pair (not just the state) in its learning process SARSA: State-Action-Reward-State-Action Bellman equation where... â€¢ ğ‘ğ‘¡ = ğœ‹ ğ‘ ğ‘¡ , ğ‘ğ‘¡+1 = ğœ‹ ğ‘ ğ‘¡+1 â€¢ ğ‘Ÿğ‘¡+1 is the reward associated to the state-action pair ğ‘ ğ‘¡, ğ‘ğ‘¡ â€¢ ğ‘ ğ‘¡+1 is the new state after selecting the action ğ‘ğ‘¡ at state ğ‘ ğ‘¡ â€¢ ğ›¼ is the learning rate 0 â‰¤ ğ›¼ â‰¤ 1 â€¢ ğ›¾ is the discount factor 0 â‰¤ ğ›¾ â‰¤ 1 â€¢ ğ‘„ ğ‘ ğ‘¡+1, ğ‘ğ‘¡+1 is the accumulated reward determines by the current ğœ‹ Source: Q-learning. Wikipedia.org. ğ‘„ ğ‘ ğ‘¡, ğ‘ğ‘¡ = 1 âˆ’ ğ›¼ Â· ğ‘„ ğ‘ ğ‘¡, ğ‘ğ‘¡ + ğ›¼ Â· ğ‘Ÿğ‘¡+1 + ğ›¾ Â· ğ‘„ ğ‘ ğ‘¡+1, ğ‘ğ‘¡+1 SARSA: State-Action-Reward-State-Action on-policy learning ğ‘ğ‘¡+1 = ğœ‹ ğ‘ ğ‘¡+1 â€¢ ğ‘„'s update does depend on the current (agent) behavior policy ğœ‹ ğ‘„ ğ‘ ğ‘¡, ğ‘ğ‘¡ = 1 âˆ’ ğ›¼ Â· ğ‘„ ğ‘ ğ‘¡, ğ‘ğ‘¡ + ğ›¼ Â· ğ‘Ÿğ‘¡+1 + ğ›¾ Â· ğ‘„ ğ‘ ğ‘¡+1, ğ‘ğ‘¡+1 SARSA: State-Action-Reward-State-Action algorithm Source: SUTTON, Richard S.; BARTO, Andrew G. Reinforcement learning: An introduction. MIT press, 2018. Q-learning versus SARSA Cliff walking example Source: SUTTON, Richard S.; BARTO, Andrew G. Reinforcement learning: An introduction. MIT press, 2018. â€¢ S: Start state â€¢ G: Goal state â€¢ actions: up, down, right, and left â€¢ reward = -1 except into â€œThe Cliffâ€ â€¢ reward = -100 in the â€œThe Cliffâ€ â€¢ ğ˜€ = 0.1 which path do you think was learned by each method? -> Q-learning -> SARSA Q-learning versus SARSA Cliff walking example Source: SUTTON, Richard S.; BARTO, Andrew G. Reinforcement learning: An introduction. MIT press, 2018. â€¢ S: Start state â€¢ G: Goal state â€¢ actions: up, down, right, and left â€¢ reward = -1 except into â€œThe Cliffâ€ â€¢ reward = -100 in the â€œThe Cliffâ€ â€¢ ğ˜€ = 0.1 which path do you think was learned by each method? Q-learning versus SARSA Cliff walking example Source: SUTTON, Richard S.; BARTO, Andrew G. Reinforcement learning: An introduction. MIT press, 2018. Reward per episode tabular solutions limitations â€¢ assumption: value estimates are represented as a table with one entry for each state or for each state-action pair â€¢ memory problems: it is limited to tasks with small numbers of states and actions; if not, there could be memory problems â€¢ generalization problems: large tables also need large volumes of data and time to generalize (fill) them properly â€¢ unobserved states: in many RL tasks, most states encountered will never have been experienced exactly before Source: SUTTON, Richard S.; BARTO, Andrew G. Reinforcement learning: An introduction. MIT press, 2018. a self-driving cab case study Source: Satwik Kansal, Brendan Martin. Reinforcement Q-Learning from Scratch in Python with OpenAI Gym. LearnDataSci, 2023. smart-cab goals areâ€¦ â€¢ pick up a passenger at one location â€¢ drop off the passenger to the right location â€¢ save time by taking the shortest path â€¢ ensure passenger safety â€¢ comply with rules a self-driving cab state space Source: Satwik Kansal, Brendan Martin. Reinforcement Q-Learning from Scratch in Python with OpenAI Gym. LearnDataSci, 2023. state space â€¢ taxi locations: a coordinate in a 5 x 5 grid â€¢ passenger locations: 5 = 4 coord. to pick up the passenger (R, G, Y, B) + 1 (taxi location) â€¢ destination locations: 4 (R, G, Y, B) â€¢ state space size = 5 x 5 x 5 x 4 = 500 states â€¢ state example: (3, 1, 2, 0) -> 328 â€¢ taxi location: coordinate (3, 1) â€¢ passenger location: 2 (Y coordinate) â€¢ destination location: 0 (R coordinate) â€¢ encoded state: 328 âˆˆ [0, 499] â€¢ enconded state = ((taxi_row * 5 + taxi_col) * 5 + passenger_location) * 4 + destination a self-driving cab action space Source: Satwik Kansal, Brendan Martin. Reinforcement Q-Learning from Scratch in Python with OpenAI Gym. LearnDataSci, 2023. action space (set of all the actions) 1. south 2. north 3. east 4. west 5. pickup 6. dropoff â€¢ action space size = 6 actions â€¢ some actions are impossible due to walls â€¢ wall hits are penalized: â€¢ penalty/reward: -1 â€¢ the taxi does not move anywhere a self-driving cab rewards Source: Satwik Kansal, Brendan Martin. Reinforcement Q-Learning from Scratch in Python with OpenAI Gym. LearnDataSci, 2023. rewards â€¢ a high positive reward for a successful dropoff â€¢ a high negative reward for a wrong dropoff â€¢ a slight negative reward for every time-step â€¢ reward table: State Space X Action Space matrix â€¢ reward table[state] returns a dictionaryâ€¦ {action: [(probability, nextstate, reward, done)]} â€¢ rewards at state (row, entry) 328 { 0: [(1.0, 428, -1, False)], 1: [(1.0, 228, -1, False)], 2: [(1.0, 348, -1, False)], 3: [(1.0, 328, -1, False)], 4: [(1.0, 328, -10, False)], 5: [(1.0, 328, -10, False)]} a self-driving cab ğ‘„-learning Source: Satwik Kansal, Brendan Martin. Reinforcement Q-Learning from Scratch in Python with OpenAI Gym. LearnDataSci, 2023. RL paradigms tabular solutions: the action-value function is represented as an array or a table approximate, gradient-descent, solutions: the state-action spaces involve continuous domains or complex representations (e.g., an image) Source: SUTTON, Richard S.; BARTO, Andrew G. Reinforcement learning: An introduction. MIT press, 2018. approximate solutions motivation â€¢ continuous, infinite state/action spaces: it requires generalization from previously experienced states to ones that have never been seen. â€¢ online function approximation o it takes earlier examples from previous interactions between the agent and the environment (bootstrap) o it learns by bootstrapping from current estimates of the value function o generalization from selected examples as in supervised learning (by comparing current function outputs against expectations) Source: SUTTON, Richard S.; BARTO, Andrew G. Reinforcement learning: An introduction. MIT press, 2018. approximate solutions introduction learning problem (the usual one) â€¢ to learn a policy ğœ‹ based on a state-value function ğœˆğœ‹ ğ‘  novelty â€¢ the unknown state-value function ğœˆğœ‹ ğ‘  is approximated by a parameterized function Æ¸ğœˆğ‘¤ ğ‘  with a parameter vector ğ‘¤ âˆˆ â„ ğ‘› â€¢ Æ¸ğœˆğ‘¤ ğ‘  can be a deep artificial neural network, with ğ‘¤ being the vector of connection weights (deep reinforcement learning) Source: SUTTON, Richard S.; BARTO, Andrew G. Reinforcement learning: An introduction. MIT press, 2018. assumption: there exist ğœˆğœ‹ ğ‘ ğ‘¡ that computes the true value from a state ğ‘ ğ‘¡ at time step ğ‘¡ under de policy ğœ‹, âˆ€ğ‘¡ = 1, 2, 3, â€¦ goal: to find ğ‘¤ such that Æ¸ğœˆğ‘¤ ğ‘ ğ‘¡ best approximates ğœˆğœ‹ ğ‘ ğ‘¡ gradient-descent method: ğ‘¤ğ‘¡+1 = ğ‘¤ğ‘¡ âˆ’ 1 2 ğ›¼ğ›» ğœˆğœ‹ ğ‘ ğ‘¡ âˆ’ Æ¸ğœˆğ‘¤ğ‘¡ ğ‘ ğ‘¡ 2 ğ‘¤ğ‘¡+1 = ğ‘¤ğ‘¡ + ğ›¼ ğœˆğœ‹ ğ‘ ğ‘¡ âˆ’ Æ¸ğœˆğ‘¤ğ‘¡ ğ‘ ğ‘¡ ğ›» Æ¸ğœˆğ‘¤ğ‘¡ ğ‘ ğ‘¡ Source: SUTTON, Richard S.; BARTO, Andrew G. Reinforcement learning: An introduction. MIT press, 2018. the change is proportional to the negative gradient of the example's squared error learning rate step-size param. ğœ• Æ¸ğœˆğ‘¤ğ‘¡ ğ‘ ğ‘¡ ğœ•ğ‘¤ğ‘¡,1 , ğœ• Æ¸ğœˆğ‘¤ğ‘¡ ğ‘ ğ‘¡ ğœ•ğ‘¤ğ‘¡,2 , â€¦ , ğœ• Æ¸ğœˆğ‘¤ğ‘¡ ğ‘ ğ‘¡ ğœ•ğ‘¤ğ‘¡,ğ‘› under certain conditions, the method converges to a local minimum approximate solutions state value function approximation what if ğœˆğœ‹ ğ‘ ğ‘¡ is unknown? the true value does not exist alternative: a rough/noisy approximation ğœˆğ‘¡ of ğœˆğœ‹ ğ‘ ğ‘¡ ; for example: ğœˆğ‘¡ = ğ‘Ÿğ‘¡+1 + ğ›¾ Æ¸ğœˆğ‘¤ğ‘¡ ğ‘ ğ‘¡+1 ğ‘ ğ‘¡+1, ğ‘Ÿğ‘¡+1 â† ğ‘’ğ‘›ğ‘£ ğ‘ ğ‘¡, ğœ‹ ğ‘ ğ‘¡ gradient-descent method: ğ‘¤ğ‘¡+1 = ğ‘¤ğ‘¡ + ğ›¼ ğœˆğ‘¡ âˆ’ Æ¸ğœˆğ‘¤ğ‘¡ ğ‘ ğ‘¡ ğ›» Æ¸ğœˆğ‘¤ğ‘¡ ğ‘ ğ‘¡ Source: SUTTON, Richard S.; BARTO, Andrew G. Reinforcement learning: An introduction. MIT press, 2018. approximate solutions state value function approximation approximate solutions deep reinforcement learning neural networks are function approximators neural networks are particularly useful in RL when the state space or action space are too large to be completely known Source: Chris V. Nicholson. A Beginner's Guide to Deep Reinforcement Learning. Pathmind Inc., 2023. neural networkstate action policy ğ‘ = à·œğœ‹ğ‘¤ ğ‘  neural networkstate value value function ğœˆ = Æ¸ğœˆğ‘¤ ğ‘  source: flickr.com CNN run? jump? stop? neural network(state, action) value Q-value function ğœˆ = Æ¸ğœˆğ‘¤ ğ‘ , ğ‘ approximate solutions deep reinforcement learning previous methods have policy implementations that directly use the value function of states or state-action pairs in choosing an action (e.g., ğœ€-greedy) actor-critic methods have a separate memory structure to explicitly represent the policy independent of the value function Source: SUTTON, Richard S.; BARTO, Andrew G. Reinforcement learning: An introduction. MIT press, 2018. approximate solutions actor-critic methods actor-critic methods introduction Source: Continuous Action Space Actor Critic Tutorial. https://youtu.be/kWHSH2HgbNQ policy net (actor) observations, sensor state value net (critic) s s ğœ‹ ğ‘ ğ‘  ğ‘‰ ğ‘  policy net (actor) s 0.17 0.04 0.72 0.07 ğœ‹ ğ‘ ğ‘  probability distribution over the action space Source: Continuous Action Space Actor Critic Tutorial. https://youtu.be/kWHSH2HgbNQ actor-critic methods discrete policy policy net (actor) s Source: Continuous Action Space Actor Critic Tutorial. https://youtu.be/kWHSH2HgbNQ (Î¼, Ïƒ) actor-critic methods continuous policy actor (policy): select actions critic (value): criticizes the actions made by the actor Source: SUTTON, Richard S.; BARTO, Andrew G. Reinforcement learning: An introduction. MIT press, 2018. actor-critic methods architecture Source: Fuji, Taiki & Ito, Kiyoto & Matsumoto, Kohsei & Yano, Kazuo. (2018). Deep Multi-Agent Reinforcement Learning using DNN-Weight Evolution to Optimize Supply Chain Performance. 10.24251/HICSS.2018.157. Source: SUTTON, Richard S.; BARTO, Andrew G. Reinforcement learning: An introduction. MIT press, 2018. actor-critic methods architecture â€¢ the critique error (a scalar) drives learning in both actor and critic â€¢ after each action ğ‘ğ‘¡, the critic evaluates the new state ğ‘ ğ‘¡ to determine whether things have gone better or worse than expected. â€¢ critique error: ğ›¿ğ‘¡ = ğ‘Ÿğ‘¡+1 + ğ›¾ğ‘£ğ‘¡ ğ‘ ğ‘¡+1 âˆ’ ğ‘£ ğ‘ ğ‘¡ â€¢ whereâ€¦ ğ‘£ğ‘¡ is the critique value at time ğ‘¡ ğ‘£ is an expected state value Deep Deterministic Policy Gradient (DDPG) an actor-critic method learning overview â€¢ ğ‘„-function (critic) and policy ğœ‡ (actor) are deep neural network models â€¢ critic and actor models are learned iteratively and alternately â€¢ learning involves off-policy data (a policy different from the target) â€¢ the actor model is a deterministic policy optimized using the critic's evaluation scope overview â€¢ DDPG is an off-policy algorithm: o the behavior policy (used to collect data) is different from the target policy o the behavior model (policy) changes continuously â€¢ DDPG can only be used for environments with continuous action spaces â€¢ DDPG uses an exploratory policy by adding noise to actions chosen by the actor Source: Deep Deterministic Policy Gradient. Copyright 2018, OpenAI. Link. Deep Deterministic Policy Gradient (DDPG) two key tricks experience replay buffer â€¢ the replay buffer (â„›) is the set of previous experiences ğ‘ ğ‘¡, ğ‘ğ‘¡, ğ‘Ÿğ‘¡+1, ğ‘ ğ‘¡+1 â€¢ â„› should be as large and diverse as possible (useful for learning) â€¢ a random minibatch â„¬ğ‘¡ of ğ‘ transitions is sampled from â„› at each learning step ğ‘¡ â€¢ â„¬ğ‘¡ is used to update both the ğ‘„-function and the policy networks target networks (intended to make the loss minimization stable) â€¢ lagging versions of the ğ‘„-function and the policy (current) networks â€¢ target networks do not change when current networks are being updated â€¢ target networks provide more stable expectations for current networks updates â€¢ target network are updated once after current network update by Polyak average (+) Source: Deep Deterministic Policy Gradient. Copyright 2018, OpenAI. Link. Deep Deterministic Policy Gradient (DDPG) experience replay buffer Source: Deep Deterministic Policy Gradient. Copyright 2018, OpenAI. Link. Replay Buffer ğ‘ ğ‘¡, ğ‘ğ‘¡, ğ‘Ÿğ‘¡+1, ğ‘ ğ‘¡+1 â„¬ğ‘¡ = ğ‘ ğ‘–, ğ‘ğ‘–, ğ‘Ÿğ‘–+1, ğ‘ ğ‘–+1 ğ‘–=1 ğ‘ Deep Deterministic Policy Gradient (DDPG) target networks ğ‘ ğ‘–+1 ğœ‡â€² (target) ğ‘„â€² (target) ğœ‡â€² ğ‘ ğ‘–+1 *ğ›¾ + ğ‘Ÿğ‘–+1 Bellman equation ğ‘„â€² ğ‘ ğ‘–+1, ğœ‡â€² ğ‘ ğ‘–+1 ğ‘„ ğœ‡ ğ‘ğ‘– ğ‘ ğ‘– ğ¿ ğ‘„ ğœƒğ‘„ ğ¿ ğ‘„ ğœƒğ‘„, ğœƒğœ‡ ğ‘„ ğ‘ ğ‘–, ğ‘ğ‘– ğ‘„ ğ‘ ğ‘–, ğœ‡ ğ‘ ğ‘– expected ğ‘„-value ğœ‡ ğ‘ ğ‘– Agent â„¬ğ‘¡ = ğ‘ ğ‘–, ğ‘ğ‘–, ğ‘Ÿğ‘–+1, ğ‘ ğ‘–+1 ğ‘–=1 ğ‘ ... Deep Deterministic Policy Gradient algorithm Source: LILLICRAP, Timothy P., et al. Continuous control with deep reinforcement learning. arXiv preprint arXiv:1509.02971, 2015. bootstrapping overview â€¢ bootstrap method: statistical technique for estimating quantities about a population by averaging estimates from multiple small data samples (sets). â€¢ a data sample is constructed by drawing individual observations from a large data sample with replacement â€¢ an observation can thus be included in a given sample more than once â€¢ bootstrapping usually perform better than nonbootstrapping methods â€¢ bootstrapping methods are of great interest to RL Source: Jason Brownlee. Gentle Introduction to the Bootstrap Method. machinelearningmastery.com, 2019 (link). bootstrapping algorithm 1. Choose a number of bootstrap samples (iterations) to perform 2. Choose a bootstrap sample size 3. For each bootstrap sample a. Draw a sample with replacement with the chosen size b. Calculate the statistic on the sample 4. Calculate the mean of the sample statistics Source: Jason Brownlee. Gentle Introduction to the Bootstrap Method. machinelearningmastery.com, 2019 (link). summary â€¢ RL goal: to learn how to map each state to the most promising action â€¢ exploitation/exploration dilemma: exploit known actions or explore new actions â€¢ RL elements: a policy ğœ‹, a reward signal, a value function, an environment model â€¢ tabular solutions: suitable for finite and small spaces of state and action â€¢ gradient-descent solutions: suitable for continuous and infinite spaces of st & act â€¢ off-policy learning: learning does not depend on the agent policy ğœ‹ â€¢ on-policy learning: learning does depend on the agent policy ğœ‹ â€¢ Deep Deterministic Policy Gradient (DDPG) is an off-policy actor-critic method â€¢ actor-critic method: policy and value functions are fully independent","libVersion":"0.3.2","langs":""}