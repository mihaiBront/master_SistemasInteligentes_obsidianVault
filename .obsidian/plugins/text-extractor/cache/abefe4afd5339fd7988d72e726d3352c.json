{"path":"_aula_virtual/SJK003/03-experimentalDesignII.pdf","text":"Department of Computer Languages and Systems Model Validation General objectives Given â€¢ a Machine Learning problem and â€¢ several classifiers/regressors applied to such a problem, we seek answers to the following questions: â€¢ how to assess the results of any classifier/regressor for the given problem? â€¢ how to make sure that the results provided by the classifier/regressor are not artificial and will hold true when the model faces unseen data? Basics of model validation â€¢ any conclusion is limited to the given problem â€¢ the learning/evaluation process should be repeated, and using some statistic of the error distribution â€¢ there are multiple measures to choose a classifier or a regressor among several: classification error, computational complexity (space/time) of the training and/or test, interpretability of the classification model, implementation complexity, â€¦ Basics of model validation (ii) Given a labeled data set, we have to divide it into three random subsets: â€¢ training set (learning), to create the model â€¢ validation set (learning), to optimize hyperparameters of the model (e.g., k of the k-NN, maximum depth of a decision tree, regularization factor of a SVM, etc.) â€¢ test set (evaluation), to assess the model with data not used in the creation of the model Generation of subsets Given a labeled data set, we want to create random subsets (training, validation, test), â€¢ as independent as possible (to minimize overlap between them) â€¢ as large as possible (to obtain robust results) â€¢ as stratified as possible (to maintain the original proportions of samples per class) Generation of subsets (ii) How many samples for learning and how many for testing? â€¢ if we have many samples to learn and few to evaluate, it can lead to overfitting â€¢ if we have many samples to evaluate and few to learn, it can lead to underfitting Thus the idea is to resample the whole data set in a way that we have enough training samples to approximate the generalization error, tune the hyperparameters controlling the model complexity, and reduce the test error Generation of subsets (iii) Resampling methods for validating models: â€¢ arbitrarily large sets (rare case) â€“ holdout â€¢ moderate or small size set (common case) â€“ K-fold cross-validation â€“ leaving-one-out â€“ 5x2 cross-validation â€“ bootstrapping Holdout Given a data set X, we randomly divide X into 2 disjoint blocks: one for training (T) and one for test/validation (V) ğ‘‡ âˆª ğ‘‰ = ğ‘‹ ğ‘‡ âˆ© ğ‘‰ = âˆ… â€¢ typically the training data set T is bigger than the evaluation data set V â€¢ common ratios used for splitting X are 60:40, 70:30, 80:20 â€¢ we can shuffle the data K different times and repeat the process for each shuffled data set (repeated holdout) â€¢ used when we do not have hyperparameters to tune Holdout (ii)A variation of Holdout Holdout is not effective for comparing multiple models and tuning their hyperparameters Solution: splitting of data into not two, but three disjoint sets: training, validation and test â€¢ the training block is divided into a portion for training and another for validation â€¢ the validation set is used to tune the hyperparameters and select the best performing algorithm â€¢ the test set is used to evaluate the final selected model A variation of Holdout (ii)K-fold cross-validation Given a data set X, we randomly divide X into K equal sized blocks X1, X2, â€¦, XK and generate K training sets and K test sets â€¢ we leave out a part and train the model on the other Kâ€“1 blocks, using the left part to evaluate the model â€¢ this process is repeated K times so that each part is used as testing set â€¢ the results from each fold are then combined and averaged to come up with the final error â€¢ typical values of K are 2, 5 and 10 K-fold cross-validation (ii) Given a data set X, we randomly divide X into K equal sized blocks X1, X2, â€¦, XK and generate K training sets and K test sets: â€¢ Iteration 1: ğ‘‰1 = X1, ğ‘‡1 = X2 âˆª X3 âˆª â‹¯ âˆª XK â€¢ Iteration 2: ğ‘‰2 = X2, ğ‘‡2 = X1 âˆª X3 âˆª â‹¯ âˆª XK â€¦ â€¢ Iteration K: ğ‘‰K = XK, ğ‘‡K = X1 âˆª X2 âˆª â‹¯ âˆª XKâˆ’1 K-fold cross-validation (iii) Example (2-fold cross-validation) â€¢ we have a subset-A with 50% of the data and a subset-B with the other 50% of the whole data set â€¢ we train the model on subset-A and evaluate the model on subset-B â€¢ we then repeat the process but this time subset-B is for training and subset-A is used as the testing set â€¢ we then average the two results and consider this value as our generalization error K-fold cross-validation (iv) Example (2-fold cross-validation) K-fold cross-validation (v) General case (e.g. 5-fold cross-validation) K-fold cross-validation (vi) Limitations â€¢ test sets Vi can be small if data set is small â€¢ any two training sets Ti, Tj share Kâ€“2 partitions â€¢ as K increases, the size of Ti increases â€¢ as data set size increases, K can be lower (we reduce importance of limitations) Leaving-one-out Given a data set X with n samples, the leaving-one-out method is a particular case of K-fold cross-validation: â€¢ we divide the whole data set X into n blocks â€¢ at each iteration, one sample is for testing and the remaining nâ€“1 samples are used to train the model â€¢ we then average the n results and consider this value as our generalization error Training Test Leaving-one-out (ii) â€¢ it is appropriate when you have a small data set since it can be a time-consuming process to use when n is large â€¢ it can also be time-consuming if a model is particularly complex and takes a long time to fit to a data set â€¢ it does not allow stratification Nested K-fold cross-validation This is a variation of K-fold cross-validation: â€¢ an inner K-fold cross-validation is performed within each training fold of the outer cross-validation, often to tune hyperparameters â€¢ at each iteration of the outer cross-validation, the inner fold is divided into K equal random parts â€¢ the inner cross-validation is repeated K times where in each iteration, Kâ€“1 parts form the training fold while the remaining K part forms the validation fold Nested K-fold cross-validation (ii)5ï‚´2 cross-validation Given a data set X, we randomly divide X into 2 equal sized blocks 5 times: ğ—ğŸ ğŸ, ğ—ğŸ ğŸ, ğ—ğŸ ğŸ, ğ—ğŸ ğŸ, â€¦ , ğ—ğŸ“ ğŸ, ğ—ğŸ“ ğŸ â€¢ we then generate 10 training sets (Ti) and 10 test sets (Vi): â€¢ ğ‘»ğŸ = ğ—ğŸ ğŸ, ğ‘½ğŸ = ğ—ğŸ ğŸ â†’ Compute Error = E1 â€¢ ğ‘»ğŸ = ğ—ğŸ ğŸ, ğ‘½ğŸ = ğ—ğŸ ğŸ â†’ Compute Error = E2 â€¦ â€¦ E = Ïƒ Eğ‘– â€¢ ğ‘»ğŸ— = ğ‘¿ğŸ“ ğŸ, ğ‘½ğŸ— = ğ‘¿ğŸ“ ğŸ â†’ Compute Error = E9 â€¢ ğ‘»ğŸğŸ = ğ‘¿ğŸ“ ğŸ, ğ‘½ğŸğŸ = ğ‘¿ğŸ“ ğŸ â†’ Compute Error = E10 5ï‚´2 cross-validation (II) It is possible divide X more than 5 times (partitions), but â€¦ â€¢ sets will share many instances (overlap) â€¢ error rates will become dependent â€¢ more error rates do not provide new information Less than 5 partitions are too few and insufficient to establish an error distribution Bootstrapping (i) Given a data set X, we generate K pairs of sets (Ti, Vi) by resampling X with replacement X = (1, 2, 3, 4, 5, 6, 7) T1 = (1, 2, 3, 4, 5) T2 = (2, 3, 4, 5, 5) T3 = (1, 1, 1, 6, 6) TK = (1, 4, 5, 7, 7) ... V1 = (1, 3, 3, 7) V2 = (2, 3, 4, 6) V3 = (1, 2, 2, 7) VK = (2, 4, 5, 6) Bootstrapping (ii) â€¢ One of the most appropriate methods with small data sets â€¢ Some drawbacks: â–ª higher levels of overlap than in cross-validation â–ª its estimated errors are more dependent","libVersion":"0.3.2","langs":""}