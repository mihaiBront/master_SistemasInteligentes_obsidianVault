{"path":"_aula_virtual/SJK003/11-numerosityReduction.pdf","text":"Department of Computer Languages and Systems Numerosity Reduction We already know â€¦ General objective of data reduction: to obtain a reduced representation of the data that is much smaller in size and make it feasible for analysis We need to reduce the data because â€¦ â€¢ data analysis could be too complex with huge data sets â€¢ data analysis could be too computational expensive with huge data sets â€¢ noisy instances can lead to misclassifications â€¢ irrelevant and redundant attributes can hinder any machine learning process We already know â€¦ Data reduction is simply .. â€¢ the reduction in the number of attributes or â€¢ the reduction in the number of instances or ïƒŸ â€¢ the reduction in both the number of instances and the number of attributes ïƒŸ Categorization Data Reduction Dimensionality Reduction Numerosity Reduction Instance Selection Prototype Generation Unit 10 Data Cleaning Data Condensing Instance selection According to the objectives, instance selection can be divided into two groups: â€¢ To improve the performance of the model â†’ Data cleaning â€¢ To reduce the size of the data set â†’ Data condensing Instance selection (ii) How to achieve those objectives? â€¢ Data cleaning: by identifying the incorrect, incomplete and inaccurate objects and then modifying, replacing or deleting them â€“ Noisy data (instances) â€“ Missing data (attributes) â€¢ Data condensing: by identifying and removing the irrelevant and redundant objects in a data set Noisy data What is noisy data? â€¢ Errors that occur during the collection process. These errors can include both erroneous attribute values (attribute noise) in samples and/or erroneous class labels (class noise) â€“ Class noise is generally considered more harmful to the learning process, and can be due to insufficient or imperfect information, subjectivity or the use of non-domain experts in data labelling, encoding or communication problems, etc. Noisy data (ii) How can class-noisy data affect the model if not tackled properly? â€“ it may deteriorate the performance of classifiers â€“ it may disrupt the class boundaries and increase overlap â€“ it may lead to overfitting â€“ it makes the problem more complex and the solution less understandable Noisy data (iii) What is an outlier? â€¢ It is data that differs considerably from all or most other data in a data set â†’ they correspond to rare, abnormal or atypical cases â€¢ It is more likely to occur outliers with large data sets, but their impact is less on the results Outliers Noisy data (iv) A simple method to detect outliers: Compute the centroid of each class, Ci for each xi in Ttra : Calculate the distance between each instance xi and its centroid Ci, d((xi, Ci) Calculate the distance between the nearest instance nni to the centroid Ci, d((nni, Ci) If d((nni, Ci)/d((xi, Ci) < ï¥ (a threshold) xi is an outlier Noisy data (v) Difference between outlier and class-noise â€¢ Both outliers and class-noise can be produced by errors. However, outliers can be also due to rare, but correct behavior that often results in interesting findings Noisy data (vi) Strategies for coping with noise: â€“ Algorithm-level approaches aim to design robust (e.g., C4.5 decision tree) or noise-tolerant (e.g., boosting) classifiers. They do not require any previous noise treatment â€“ Data-level approaches attempt to remove or correct the noise present in the data before applying any standard classification algorithm. This is the best option if using a robust learner is unfeasible or inappropriate, or even aiming to improve results of robust learners â€¢ Filtering (or editing) methods â€¢ Relabelling methods Noisy data (vii): Filtering Data-level approaches: â€“ Filtering methods identify and remove noisy instances and â€˜cleanâ€™ the possible overlap between classes â†’ as a by-product, they obtain a reduction in the data set size â€¢ In general, the filtering or editing methods attempt to remove border instances (i.e., those close to the decision boundary) â†’ this leads to smoothing the boundaries of the classification regions Overlap region Noisy data (viii): Filtering Wilsonâ€™s editing (Ttra, k) S ï‚¬ Ttra for each xi in Ttra : search for the k nearest neighbours to xi in Ttra â€“ {xi} if the class given by the k-NN ï‚¹ ci S ïƒŸ S â€“ {xi} return S â€“ Note that it uses leaving-one out â€“ Computational cost is O(n2) D.L. Wilson (1973) Asymptotic properties of nearest neighbor rules using edited data. IEEE Trans. on Systems, Man, and Cybernetics 2, 408-421 Noisy data (ix): Filtering Wilsonâ€™s editing: an example Original set with 2500 instances Edited set with 1105 instances Noisy data (x): Relabelling Data-level approaches: â€“ Relabelling methods consists of changing the class labels of training instances that are suspected to be noisy and belong to different classes Noisy data (xi): Relabelling Editing with relabelling (Ttra, k, l) S ï‚¬ Ttra for each xi in Ttra : search for the k nearest neighbours to xi in Ttra â€“ {xi} if the class given by the (k,l)-NN ï‚¹ ci ï‚¹ c0 relabel xi with the class given by (k,l)-NN else if the class given by the (k,l)-NN = c0 S ïƒŸ S â€“ {xi} return S Noisy data (xii) There exist many other data-level algorithms: â€“ Multiedit â€“ Iterative partitioning filter â€“ Graph-based editing (Gabriel graph, RNG) â€“ Fuzzy rough prototype selection â€“ Reward-punishment editing â€“ Model class selection â€“ Iterative case filtering â€“ Edited normalized radial basis function â€“ Etc. Missing data What is missing data? â€¢ Values or data not stored for some attributes due to human errors during data entry, system malfunction during data collection, respondents refusal to answer certain questions, etc. Missing data (ii) How can missing data affect the model if not tackled properly? â€“ it may lead to a performance degradation â€“ it may lead to biased machine learning models Most ML models fail if the data set contains missing values! Missing data (iii): Types â€¢ Missing Completely At Random (MCAR): there is no relationship between the missing data and any other values observed within the data set â€¢ Missing At Random (MAR): the reason for missing values can be explained by variables on which you have complete information as there is some relationship between the missing data and other values â€¢ Missing Not At Random (MNAR): if the missing data does not fall under MCAR or MAR, then it can be categorized as MNAR Missing data (iv): Examples of types â€¢ MCAR: suppose a library where some values of overdue books in the system are missing, maybe because the librarian forgot to type in the values. So, the missing values of overdue books are not related to any other variable in the system â€¢ MAR: suppose a survey in which all the people have answered their â€˜Ageâ€™ but â€˜IQ Scoreâ€™ values are mostly missing for older people. In this case, the variables â€˜Ageâ€™ and â€˜IQ Scoreâ€™ are related and the reason for missing values of the â€˜IQ Scoreâ€™ variable can be explained by the â€˜Ageâ€™ variable â€¢ MNAR: suppose the name and the number of overdue books are asked in the poll for a library. So, most of the people having no overdue books are likely to answer the poll. People having more overdue books are less likely to answer the poll Missing data (v): Techniques â€¢ Deletion: all objects with missing values in some attributes are removed â€“ If the count of missing values in the data is very high, then deletion can lead to a very significant decrease in the number of instances â€“ we may end up deleting some potentially useful information â€¢ Imputation: it involves replacing missing values by some predicted values, typically using the non-missing values Missing data (vi): Techniques Deletion techniques â€“ Deletion of entire row (object): if an instance is containing many attributes with missing values then it is unlikely to add any value to our model â†’ also known as listwise deletion â€“ Deletion of the entire column (attribute): if a certain attribute has a high majority of instances with missing values, then we can drop the entire column Missing data (vii): Techniques Imputation techniques â€“ Replacing with mean: if the data in the attribute is skewed or there are outliers, replacing missing values by mean will add bias to the data â€“ Replacing with median: a safe choice if the data in attribute is skewed with outliers â€“ Replacing with mode (the most frequent value): this technique can be applied to both numerical and categorical data Missing data (vii): Techniques Other imputation techniques â€“ Replacing with previous value (forward fill): imputing the values with the previous value instead of mean, mode or median. It is mostly used in time series data â€“ Replacing with next value (backward fill): the missing value is imputed using the next value â€“ Nearest neighbours imputation: the k-NN model with the Euclidean distance is used to replace the missing values with the value of the nearest neighbours â€“ Regression-based imputation: the missing values are estimated with linear, logistic or stochastic regression Data condensing Objective â€“ to reduce the size of the training set, but â€¦ â€“ it should not worsen the performance of the classifier Result â€“ it produces a reduced set that can classify (equally) well as the original training set â€“ storage and computing requirements are lowered Data condensing (ii) How condensing algorithms work? â€“ they identify and remove irrelevant and redundant instances from a training set â€¢ In general, the condensing methods attempt to remove internal instances (i.e., those far from the decision boundary) because they can be safely removed without loss of accuracy Data condensing (iii) Training-set consistency â€“ Given a non-empty set T (T ï‚¹ ïƒ†), a subset S of T (S ïƒ T) is consistent with respect to T if, using the subset S as training set, the 1-NN classifier can correctly classify all instances in T (100% training accuracy) P.E. Hart (1968) The Condensed Nearest Neighbor Rule. IEEE Trans. on Information Theory 14, 515-516 Data condensing (iv) Hartâ€™s condensing (Ttra) S ï‚¬ ïƒ† repeat for each xi in Ttra : search for the nearest neighbour to xi in S if the class given by the k-NN ï‚¹ ci T ïƒŸ Ttra â€“ {xi} S ïƒŸ S + {xi} until T = ïƒ† or no more removals from T return S P.E. Hart (1968) The Condensed Nearest Neighbor Rule. IEEE Trans. on Information Theory 14, 515-516 Data condensing (v) Hartâ€™s condensing: â€“ it removes internal instances â†’ those instances that are not needed to correctly classify the remaining instances in the training set â€“ it is not a deterministic approach â†’ the content and cardinality of the resulting set depend on the order in which the instances are processed â€“ it produces a reduced set, but minimality cannot be guaranteed Data condensing (vi) Hartâ€™s condensing: an example CNN (0.7729,0.8664)Banana Original (,0.8751) Data condensing (vii) There exist many other data condensing algorithms: â€“ Tomek links â€“ Minimal consistent set â€“ Patterns by ordered projection â€“ Decremental reduction optimization procedure (DROP1-5) â€“ Adaptive threshold-based instance selection â€“ Mutual neighborhood value â€“ Graph-based condensing (Gabriel graph, RNG) â€“ Spectral instance reduction â€“ Etc. Prototype generation Similar objective to that of data condensing methods â€“ to create a small-sized set of exemplars (or prototypes) from the original training set, but â€¦ â€“ it should maintain the accuracy of the classifier However, â€“ prototype generation algorithms are not limited to just selecting instances from the training set as they can also modify their location in d-dimensional space or generate artificial prototypes â€“ most algorithms use merging or divide-and-conquer strategies to create the artificial prototypes, or rely on clustering approaches Prototype generation (ii) What characteristics should the prototypes have? â€“ they are shaped to represent class distributions efficiently and to discriminate well between classes â€“ its cardinality should be small enough to reduce both storage and computing time of the classifier Prototype generation (iii) Strategies: â€“ Centroid-based methods generate artificial prototypes by merging similar instances of the same class in successive iterations. The artificial prototypes correspond to the centroids of the merged instances â€“ Positioning adjustment methods generate the artificial prototypes by â€˜correctingâ€™ the position of the training instances through an optimization procedure â€“ Space partitioning methods rely on different heuristics to partition the feature space into several regions and generate the artificial prototypes by using representative examples Prototype generation (iv) Some algorithms: â€“ Centroid-based methods â€¢ H.A. Fayed, S.R. Hashem, A. F. Atiya (2007) Self-generating prototypes for pattern classification. Pattern Recognition 40, 1498-1509 â€¢ S. Ougiaroglou, G. Evangelidis (2014) RHC: non-parametric cluster-based data reduction for efficient k-NN classification, Pattern Analysis and Applications 19, 93-109 â€“ Positioning adjustment methods â€¢ T. Kohonen (1990) The self organizing map. Proceedings of the IEEE 78,146-1480 â€¢ I. Triguero, S. GarcÃ­a, F. Herrera (2010) IPADE: Iterative prototype adjustment for nearest neighbor classification. IEEE Trans. on Neural Networks 21, 1984-1990 â€“ Space partitioning methods â€¢ J.S. SÃ¡nchez (2004) High training set size reduction by space partitioning and prototype abstraction. Pattern Recognition 37, 1561-1564 â€¢ T. Raicharoen, C. Lursinsap (2005) A divide-and-conquer approach to the pairwise opposite class-nearest neighbor (POC-NN) algorithm. Pattern Recognition Letters 26, 1554-1567 Prototype generation (v) Class homogeneity â€“ A non-empty set T (T ï‚¹ ïƒ†) is said to be class homogeneous if it does not contain a mixture of instances that belong to different classes Diameter of a set â€“ The diameter of a non-empty set T (T ï‚¹ ïƒ†) is defined as the distance between its two farthest instances J.S. SÃ¡nchez (2004) High training set size reduction by space partitioning and prototype abstraction. Pattern Recognition 37, 1561-1564 Prototype generation (vi) Reduction through Homogeneous Clustering (RHC) S ï‚¬ ïƒ† R ï‚¬ Ttra repeat clusters ï‚¬ C-means(R, classes_in(R)) for each Ci in clusters if Ci is class-homogeneous S ï‚¬ centroid(Ci) R ï‚¬ R â€“ {xj}, xj ïƒŽ classi until R = ïƒ† return S Prototype generation (vii) Reduction by Space Partitioning v3 (RSP3) 1. Compute the diameter of Ttra given by the two farthest instances, say p1 and p2 2. Form two clusters by assigning each training instance to its closest farthest instance: ð¶1 = ð‘¥ð‘– âˆˆ ð‘‡ð‘¡ð‘Ÿð‘Ž: ð‘‘(ð‘¥ð‘–, ð‘1) â‰¤ ð‘‘(ð‘¥ð‘–, ð‘2) ð¶2 = ð‘¥ð‘– âˆˆ ð‘‡ð‘¡ð‘Ÿð‘Ž: ð‘‘(ð‘¥ð‘–, ð‘2) < ð‘‘(ð‘¥ð‘–, ð‘1) These steps are applied recursively on each non-homogeneous cluster. At the end, each homogeneous cluster is replaced by its centroid to form the reduced set Prototype generation (viii) Example of a centroid-based method Reduced set with 5 prototypesEdited set with 1105 instances Prototype generation (ix) Example of a positioning adjustment method over the Banana data set Prototype generation (x) Example of a space partitioning method A synthetic problem with 2 non- overlapping interlaced classes: The algorithm generated 10 prototypes, which is the minimum number to fully define the decision boundaries of the 1- NN classifier","libVersion":"0.3.2","langs":""}