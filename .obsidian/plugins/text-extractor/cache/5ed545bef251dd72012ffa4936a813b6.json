{"path":"_aula_virtual/SJK002/LABS/lab6.pdf","text":"Computer Vision M ´aster en Sistemas Inteligentes (Universitat Jaume I) 6. Optic ﬂow estimation Abstract Optic ﬂow estimation is an important building block for applications where visual information change dynamically over time. Mobile robot navigation, trafﬁc monitoring, and human action recognition are three examples, among many others, which require or can beneﬁt from optic ﬂow information. In this lab, we will implement one simple, but foundational method for optic ﬂow computation, the classical Lucas-Kanade algorithm. Keywords Optic ﬂow • Lucas-Kanade algorithm Contents 1 Lucas-Kanade algorithm 1 1.1 Computing the gradients . . . . . . . . . . . . . . . . . 1 1.2 Computing AT A and AT b . . . . . . . . . . . . . . . . . . 1 1.3 Solving for the ﬂow . . . . . . . . . . . . . . . . . . . . . . 1 2 Synthetic motion 1 3 Real sequences 2 4 Additional and optional activities 2 1. Lucas-Kanade algorithm Our ﬁrst task is to complete the function u,v = optical_flow(I1, I2, window_size, tau) to compute the optic ﬂow (u, v) between the image pair (I1, I2) with Lucas-Kanade (LK) algorithm, using local square win- dows of side length w (window_size), and τ (tau) as the minimum value of the eigenvalues of the matrix AT A. Let’s proceed step by step. Computing the gradients We ﬁrst smooth the input images with a Gaussian ﬁlter, and then we have to compute the spatio-temporal gradients, Ix, Iy and It on the smoothed images. To that end, we deﬁne the corresponding three kernels for the x, y and t directions, and then apply 2D convolutions. The kernel and convolution for x is given. 1 ▶ Now, write the code to deﬁne the two other kernels and apply their respective convolutions. For the temporal gradient, follow this: It = (I2 − I1) ∗ Mt = I2 ∗ Mt − I1 ∗ Mt , where Mt is the 4 × 4 mask for a mean ﬁlter. Notation reminder: we use ∗ to denote the convolution operation (not a matrix product or an elementwise product), and Ih represents the image derivative with respect to the axis h ∈ {x, y,t}. Computing AT A and AT b Remember that in LK method, for each local window of n pixels, we have that Au = −b, where A is the n × 2 matrix of the n spatial gradients, and b is the n × 1 vector of temporal derivatives. To ﬁnd out the optic ﬂow u for that window we have that u = (AT A)−1AT b. In the provided code, you are given the arrays Ix, Iy, and It that contain the corresponding derivatives just for the local window around a particular pixel at (i, j). From these, 2 ▶ you only have to compute the variables AtA (for AT A) and Atb (for AT b). Solving for the ﬂow Finally, 3 ▶ we can use linalg.lstsq(C,d) to compute the least-squares solution x to Cx = d. Just pay attention to what matrix C, vector d, and x are in our case. Remember that we can only compute the optic ﬂow in those image locations where AT A is well-conditioned. So, before solving for u we must check for this. 4 ▶ We can verify that either the smalllest eigenvalue for AT A is larger than τ, or that AT A has rank 2. For this, we can rely on np.linalg.eigvals() and np.linalg.matrix rank(), respectively. 2. Synthetic motion We now have to test how optical_flow() works. Since the basic LK algorithm assumes small motions, it is good that we can generate the motions we want, under controlled conditions. It is harder to ﬁnd real sequences that have the motion we are interested to check. As you can see in the code, we use SimilarityTransform() to deﬁne the transformation with the desired amounts of trans- lation, scale and rotation, which is then applied to the actual image with warp(). To visualize the computed ﬂow, you are provided with the function display_optic_flow(). Good visualisations of outputs of algorithms of optic ﬂow (and others) is always critically important during the development and analysis of these algorithms. In the following, you can use the threshold τ = 0.01. 5 ▶ Experiment with different amounts of translation and ﬁnd out up to which mangitudes LK fares well. 6 ▶ Regarding 6. Optic ﬂow estimation — 2/2 what the function plot_optic_flow() displays, make sure you understand, besides the arrows, what the colors in the background represents. Check the results look qualitatively good (when translation is small enough). 7 ▶ Complement this visual inspection of the ﬂow map with the histogram of the magnitude of the optical ﬂow. 8 ▶ Vary also the window size w (from the smallest w = 3 up to a few tens) and notice the impact on the estimated ﬂow (both the map and the magnitude histogram). Does w have an inﬂuence on the sparsity/density or smoothness of the map? Try to ﬁnd an explanation. 9 ▶ Repeat the above experimentation with the scale fac- tor (both “zoom in” and “zoom out”), and then with rotations. Notice that, unlike the translations, the magnitude of the ﬂow at different image positions should be different. Make sure the output make sense, qualitatively. 3. Real sequences We can now study how optic ﬂow performs in some image se- quences from real scenes. Although ground-truth optic ﬂow is hardly available in these cases and, therefore, estimation error cannot be easily computed, we can anyway evaluate the result qualitatively in these more challenging (and interesting) sce- narios, where one or more objects may ymove independently, in contrat to the global movement of the previous synthetic examples. 10 ▶ Experiment on some of consecutive frames of the Hamburg taxi sequence, which is one example of the classical sequences which optic ﬂow methods used to be tested on. Although local motion in this sequence can be considered to be “large” and, therefore, the vanilla LK method might not perform very well, ﬁnd for which window sizes w we can get reasonable results. What potential beneﬁt can we get by increasing τ one or two orders of magnitude? 4. Additional and optional activities Remember that all exercises are optional, and those marked explicitly as “optional” are particularly so. We propose many optional exercises because we do not want you to be left want- ing more activities. Of course, this does not mean we want you to try them all, let alone complete them all successfully. Therefore, be wise and selective in which exercises you want to try and how much time/effort you are willing to invest, depending on your background, your available time, your goals. . . 11 ▶ (Optional) Compute the Gaussian pyramid of the input images (you can use pyramid gaussian). Experiment a little bit on the estimation of ﬂow at different levels of the pyramid: as you know, the optic ﬂow becomes smaller at downscaled verions of the images, which is the basic observa- tion for the coarse-to-ﬁne version of the LK algorithm. 12 ▶ (Optional) Try to approximately segment the ob- ject(s) in real sequences using optical ﬂow information. The idea is to use one simple segmentation algorithm that you know (maybe Otsu), but instead of applying it on gray-level values, we can use optic ﬂow. After the segmentation, we can ﬁnd the regions (connected components). For instance, can we isolate the different vehicles in the taxi sequence? 13 ▶ (Optional) Write and test a function to display several optic-ﬂow information (e.g., u, v, orientation and mag- nitude). You may take this opportunity to learn about the ﬂexibility of arranging multiple Matplotlib axes in a grid that is offered by GridSpec. 14 ▶ (Optional) Study the quiver() function to display the output of optic ﬂow, which is used in our display optic flow(). 15 ▶ (Optional) Learn about about a commonly used color wheel representation which combines the magnitude and orientation into a single 2D map. You can ﬁnd examples in, for instance, this paper. Try some available implementation of this color coding, or implement it yourself. The following exercises are more open, and possibly harder and signiﬁcantly more time consuming. Some are even advanced. Therefore, you should only consider them if you ﬁnd them, or the topic of this lab, motivating or interest- ing, and you have lot of spare time to spend on them. After all, they are less relevant in the context of our introductory course. 16 ▶ (Optional, advanced) Implement and experiment with a hierarchical, coarse-to-ﬁne version of LK. We can expect that larger motions can be estimated. 17 ▶ (Optional) Try the Python implementation of the hierarchical LK in OpenCV on some sequences (the ones used in this lab and/or others) and compare with our basic (single-level) implementation. You may also like to follow this tutorial. 18 ▶ (Optional) Consider one of the full real sequences, and generate either an on-screen animation (with Matplotlib), or a nice-looking video of some representaiton of the com- puted ﬂow, either alone or overlapped with the frames. 19 ▶ (Optional, advanced) Study some other well-known and good optic ﬂow method . For instance, for the mathe- matically inclined, in the pre-deep-learning erea, variational methods were popular in computer vision. Brox et al. (ECCV 2004) proposed a variational algorithm for optical ﬂow. If you wish, ﬁnd also some available implementation of this (or other) approach, and experiment a little bit with it. You should at least observe that this better methods outperform our simple LK implementation. 20 ▶ (Optional, advanced) Find some (small) dataset with available optic ﬂow ground-truth. Find out which perfor- mance metrics are commonly used to assess the performance. Then, you can run LK under different w, or other OF methods, and compare the results against the ground-truth using some of those metrics.","libVersion":"0.3.2","langs":""}